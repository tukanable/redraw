<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            z-index: 100;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
            background: white;
            margin-top: 60px;
            width: 100vw;
            height: calc(100vh - 60px);
        }
        
        #accuracy {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        
        #attempts {
            font-size: 14px;
            color: #666;
        }
        
        #lastResults {
            font-size: 12px;
            color: #555;
            flex: 1;
        }
        
        #successRate {
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }
        
        #settings {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #settings label {
            font-size: 12px;
            color: #666;
        }
        
        #thresholdInput, #radiusInput, #minLengthInput, #maxLengthInput, #modeSelect {
            width: 50px;
            padding: 3px 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
        }
        
        #modeSelect {
            width: 120px;
        }
        
        #graphContainer {
            width: 200px;
            height: 50px;
            position: relative;
        }
        
        #graph {
            width: 100%;
            height: 100%;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .info-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="info-group">
            <div id="accuracy">Точность: 0%</div>
            <div id="successRate">Успех: 0%</div>
        </div>
        <div id="attempts">Попытка: 1</div>
        <div id="graphContainer">
            <canvas id="graph"></canvas>
        </div>
        <div id="lastResults">Последние 10: -</div>
        <div id="settings">
            <label>Режим:</label>
            <select id="modeSelect" onchange="saveMode()">
                <option value="line">Линия</option>
                <option value="points">Точки</option>
            </select>
            <label>Авто %:</label>
            <input type="number" id="thresholdInput" min="50" max="99" value="98" onchange="saveThreshold()">
            <label>Радиус:</label>
            <input type="number" id="radiusInput" min="50" max="200" value="100" onchange="saveRadius()">
            <label>Длина:</label>
            <input type="number" id="minLengthInput" min="50" max="500" value="100" onchange="saveLineLength()">
            <span>-</span>
            <input type="number" id="maxLengthInput" min="50" max="500" value="300" onchange="saveLineLength()">
        </div>
        <button onclick="generateNewLine()">Новая линия</button>
        <button onclick="clearAttempts()">Очистить</button>
    </div>
    <canvas id="canvas"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to full window minus toolbar
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 60; // Account for toolbar height
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Line trainer system
        let targetLine = [];
        let userStrokes = []; // Array of strokes, each stroke is an array of points
        let currentStroke = [];
        let currentAccuracy = 0;
        let attemptHistory = [];
        let currentAttempt = 1;
        let autoChangeThreshold = 98;
        let currentMousePos = { x: 0, y: 0 };
        let indicatorRadius = 100;
        let minLineLength = 100;
        let maxLineLength = 300;
        let currentRadius = 0;
        let targetRadius = 0;
        let currentMode = 'line';
        
        // Chart.js graph
        let accuracyChart = null;
        
        // Drawing settings
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        function startDrawing(e) {
            isDrawing = true;
            const [x, y] = getEventPos(e);
            [lastX, lastY] = [x, y];
            
            // Start new stroke
            currentStroke = [{ x, y }];
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const [currentX, currentY] = getEventPos(e);
            currentMousePos = { x: currentX, y: currentY };
            
            // Add point to current stroke
            currentStroke.push({ x: currentX, y: currentY });
            
            // Redraw everything
            redrawCanvas();
            
            // Calculate accuracy
            calculateAccuracy();
            
            [lastX, lastY] = [currentX, currentY];
        }
        
        function generateNewLine() {
            // Clear previous drawings
            userStrokes = [];
            currentStroke = [];
            targetLine = [];
            attemptHistory = [];
            currentAttempt = 1;
            
            // Reset radius animation
            currentRadius = 0;
            targetRadius = 0;
            
            // Generate random straight line with configured length
            const lineLength = minLineLength + Math.random() * (maxLineLength - minLineLength);
            const angle = Math.random() * Math.PI * 2; // Random angle
            
            // Start position - ensure line fits on canvas with padding
            const padding = 50;
            const maxX = canvas.width - padding;
            const maxY = canvas.height - padding;
            const minX = padding;
            const minY = padding;
            
            // Generate random start point within safe area
            let startX, startY, endX, endY;
            let attempts = 0;
            
            do {
                startX = minX + Math.random() * (maxX - minX);
                startY = minY + Math.random() * (maxY - minY);
                endX = startX + Math.cos(angle) * lineLength;
                endY = startY + Math.sin(angle) * lineLength;
                
                // Try new angle if line goes out of bounds
                if (endX < minX || endX > maxX || endY < minY || endY > maxY) {
                    angle = Math.random() * Math.PI * 2;
                }
                attempts++;
            } while ((endX < minX || endX > maxX || endY < minY || endY > maxY) && attempts < 50);
            
            // Fallback: ensure line stays within bounds
            if (endX < minX || endX > maxX || endY < minY || endY > maxY) {
                endX = Math.max(minX, Math.min(maxX, endX));
                endY = Math.max(minY, Math.min(maxY, endY));
            }
            
            // Generate points along the straight line
            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const steps = Math.ceil(distance / 2); // Point every 2 pixels
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = startX + (endX - startX) * t;
                const y = startY + (endY - startY) * t;
                targetLine.push({ x, y });
            }
            
            currentAccuracy = 0;
            updateAccuracyDisplay();
            updateAttemptsDisplay();
            updateLastResultsDisplay();
            clearGraph();
            redrawCanvas();
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw target based on current mode
            if (targetLine.length > 1) {
                if (currentMode === 'line') {
                    // Draw full line (gray, dashed)
                    ctx.strokeStyle = '#888888';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(targetLine[0].x, targetLine[0].y);
                    for (let i = 1; i < targetLine.length; i++) {
                        ctx.lineTo(targetLine[i].x, targetLine[i].y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (currentMode === 'points') {
                    // Draw only start and end points
                    const startPoint = targetLine[0];
                    const endPoint = targetLine[targetLine.length - 1];
                    
                    ctx.fillStyle = '#888888';
                    
                    // Start point
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // End point
                    ctx.beginPath();
                    ctx.arc(endPoint.x, endPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Optional: draw small labels
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('S', startPoint.x, startPoint.y + 4);
                    ctx.fillText('E', endPoint.x, endPoint.y + 4);
                }
            }
            
            // Draw all user strokes
            ctx.lineWidth = 4;
            
            for (let stroke of userStrokes) {
                if (stroke.length > 1) {
                    drawColoredStroke(stroke);
                }
            }
            
            // Draw current stroke with color based on distance from target
            if (currentStroke.length > 1) {
                drawColoredStroke(currentStroke);
            }
            
            // Draw floating accuracy indicator near cursor
            if (isDrawing && currentMousePos.x > 0 && currentMousePos.y > 0) {
                drawFloatingAccuracy();
            }
        }
        
        function calculateAccuracy() {
            // Combine all user strokes and current stroke
            let allUserPoints = [];
            for (let stroke of userStrokes) {
                allUserPoints = allUserPoints.concat(stroke);
            }
            allUserPoints = allUserPoints.concat(currentStroke);
            
            if (allUserPoints.length === 0 || targetLine.length === 0) {
                currentAccuracy = 0;
                updateAccuracyDisplay();
                return;
            }
            
            // Calculate coverage - how much of the target line is covered
            let coveredTargetPoints = 0;
            const coverageThreshold = 15; // pixels
            
            for (let targetPoint of targetLine) {
                let isCovered = false;
                for (let userPoint of allUserPoints) {
                    const distance = Math.sqrt(
                        Math.pow(userPoint.x - targetPoint.x, 2) + 
                        Math.pow(userPoint.y - targetPoint.y, 2)
                    );
                    if (distance <= coverageThreshold) {
                        isCovered = true;
                        break;
                    }
                }
                if (isCovered) {
                    coveredTargetPoints++;
                }
            }
            
            const coverage = coveredTargetPoints / targetLine.length;
            
            // Calculate precision - how close user points are to target
            let totalDistance = 0;
            let validPoints = 0;
            
            for (let userPoint of allUserPoints) {
                let minDistance = Infinity;
                
                for (let targetPoint of targetLine) {
                    const distance = Math.sqrt(
                        Math.pow(userPoint.x - targetPoint.x, 2) + 
                        Math.pow(userPoint.y - targetPoint.y, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                }
                
                if (minDistance < 30) { // Only count points within 30px
                    totalDistance += minDistance;
                    validPoints++;
                }
            }
            
            let precision = 0;
            if (validPoints > 0) {
                const averageDistance = totalDistance / validPoints;
                precision = Math.max(0, Math.min(100, 100 - (averageDistance * 3)));
            }
            
            // Calculate overdrawn penalty
            const idealUserPoints = targetLine.length;
            const overdrawRatio = allUserPoints.length / idealUserPoints;
            let overdrawPenalty = 1;
            
            if (overdrawRatio > 1.2) {
                // Penalty for drawing too much
                overdrawPenalty = Math.max(0.5, 1 - (overdrawRatio - 1.2) * 0.5);
            }
            
            // Calculate overlap penalty (drawing multiple times over same area)
            let overlapPenalty = 1;
            let overlapCount = 0;
            
            for (let i = 0; i < allUserPoints.length; i++) {
                for (let j = i + 1; j < allUserPoints.length; j++) {
                    const distance = Math.sqrt(
                        Math.pow(allUserPoints[i].x - allUserPoints[j].x, 2) + 
                        Math.pow(allUserPoints[i].y - allUserPoints[j].y, 2)
                    );
                    if (distance < 5) { // Very close points indicate overlap
                        overlapCount++;
                    }
                }
            }
            
            if (overlapCount > allUserPoints.length * 0.1) {
                overlapPenalty = Math.max(0.7, 1 - (overlapCount / allUserPoints.length));
            }
            
            // Final accuracy combines coverage, precision, and penalties
            currentAccuracy = Math.max(0, Math.min(100, 
                coverage * precision * overdrawPenalty * overlapPenalty
            ));
            
            updateAccuracyDisplay();
        }
        
        function updateAccuracyDisplay() {
            document.getElementById('accuracy').textContent = `Точность: ${Math.round(currentAccuracy)}%`;
        }
        
        function stopDrawing() {
            if (isDrawing && currentStroke.length > 0) {
                // Calculate final accuracy for this attempt
                calculateAccuracy();
                
                // Record this attempt
                attemptHistory.push(currentAccuracy);
                currentAttempt++;
                updateAttemptsDisplay();
                updateLastResultsDisplay();
                updateGraph();
                
                // Check if average accuracy of last 10 attempts is above threshold
                if (attemptHistory.length >= 10) {
                    const last10 = attemptHistory.slice(-10);
                    const averageAccuracy = last10.reduce((sum, acc) => sum + acc, 0) / last10.length;
                    
                    if (averageAccuracy >= autoChangeThreshold) {
                        setTimeout(() => {
                            generateNewLine();
                        }, 1000); // Delay to show the result
                    }
                }
                
                // Clear all strokes after recording the result
                userStrokes = [];
                currentStroke = [];
                
                // Redraw canvas with only target line
                redrawCanvas();
            }
            isDrawing = false;
        }
        
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', (e) => {
            const [x, y] = getEventPos(e);
            currentMousePos = { x, y };
            draw(e);
        });
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events for tablet support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });
        
        // Prevent scrolling when touching the canvas
        document.body.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchend', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        function updateAttemptsDisplay() {
            document.getElementById('attempts').textContent = `Попытка: ${currentAttempt}`;
        }
        
        function updateLastResultsDisplay() {
            const last10 = attemptHistory.slice(-10);
            if (last10.length === 0) {
                document.getElementById('lastResults').textContent = 'Последние 10: -';
                document.getElementById('successRate').textContent = 'Успех за 10: 0%';
                return;
            }
            
            const resultsText = last10.map(acc => Math.round(acc) + '%').join(', ');
            document.getElementById('lastResults').textContent = `Последние ${last10.length}: ${resultsText}`;
            
            // Calculate average success rate
            const averageAccuracy = last10.reduce((sum, acc) => sum + acc, 0) / last10.length;
            const successRate = Math.round(averageAccuracy);
            document.getElementById('successRate').textContent = `Успех за 10: ${successRate}%`;
        }
        
        function getDistanceColor(distance) {
            // Color based on distance from target line
            // Green when close (0-5px), yellow (5-15px), red (15px+)
            if (distance < 5) {
                // Very close - bright green
                return 'rgb(0, 255, 0)';
            } else if (distance < 15) {
                // Medium distance - yellow to orange
                const progress = (distance - 5) / 10;
                const red = Math.round(255);
                const green = Math.round(255 * (1 - progress * 0.5));
                return `rgb(${red}, ${green}, 0)`;
            } else {
                // Far - red
                return 'rgb(255, 0, 0)';
            }
        }
        
        function drawColoredStroke(stroke) {
            if (stroke.length < 2) return;
            
            // Draw each segment with color based on distance to target
            for (let i = 1; i < stroke.length; i++) {
                const point = stroke[i];
                const prevPoint = stroke[i - 1];
                
                // Find minimum distance to target line for this point
                let minDistance = Infinity;
                for (let targetPoint of targetLine) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - targetPoint.x, 2) + 
                        Math.pow(point.y - targetPoint.y, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                }
                
                // Draw segment with appropriate color
                ctx.strokeStyle = getDistanceColor(minDistance);
                ctx.beginPath();
                ctx.moveTo(prevPoint.x, prevPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
        }
        
        function drawFloatingAccuracy() {
            const x = currentMousePos.x;
            const y = currentMousePos.y;
            
            // Find minimum distance to target line
            let minDistance = Infinity;
            for (let targetPoint of targetLine) {
                const distance = Math.sqrt(
                    Math.pow(x - targetPoint.x, 2) + 
                    Math.pow(y - targetPoint.y, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
            
            // Calculate target radius based on distance
            // Close to line (0-5px) = small radius (10% of base)
            // Far from line (30px+) = full radius
            const maxDistance = 30;
            const normalizedDistance = Math.min(minDistance, maxDistance) / maxDistance;
            const minRadius = indicatorRadius * 0.1;
            targetRadius = minRadius + (indicatorRadius - minRadius) * normalizedDistance;
            
            // Smooth interpolation (lerp) with time factor
            const lerpSpeed = 0.15; // Adjust for faster/slower animation
            currentRadius = currentRadius + (targetRadius - currentRadius) * lerpSpeed;
            
            // Draw semi-transparent gray circle
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#888888';
            ctx.beginPath();
            ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw border
            ctx.globalAlpha = 0.5;
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function initChart() {
            const ctx = document.getElementById('graph').getContext('2d');
            accuracyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Точность',
                        data: [],
                        borderColor: '#007bff',
                        backgroundColor: 'rgba(0, 123, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: 2,
                        pointBackgroundColor: '#007bff',
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: true,
                            min: 0,
                            max: 100,
                            ticks: {
                                display: false
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        function updateGraph() {
            if (!accuracyChart) return;
            
            const last10 = attemptHistory.slice(-10);
            accuracyChart.data.labels = last10.map((_, i) => i + 1);
            accuracyChart.data.datasets[0].data = last10;
            accuracyChart.update('none');
        }
        
        function clearGraph() {
            if (!accuracyChart) return;
            accuracyChart.data.labels = [];
            accuracyChart.data.datasets[0].data = [];
            accuracyChart.update('none');
        }
        
        function clearAttempts() {
            userStrokes = [];
            currentStroke = [];
            attemptHistory = [];
            currentAttempt = 1;
            currentAccuracy = 0;
            updateAccuracyDisplay();
            updateAttemptsDisplay();
            updateLastResultsDisplay();
            clearGraph();
            redrawCanvas();
        }
        
        function saveThreshold() {
            const input = document.getElementById('thresholdInput');
            autoChangeThreshold = parseInt(input.value);
            localStorage.setItem('autoChangeThreshold', autoChangeThreshold);
        }
        
        function saveRadius() {
            const input = document.getElementById('radiusInput');
            indicatorRadius = parseInt(input.value);
            localStorage.setItem('indicatorRadius', indicatorRadius);
        }
        
        function saveLineLength() {
            const minInput = document.getElementById('minLengthInput');
            const maxInput = document.getElementById('maxLengthInput');
            minLineLength = parseInt(minInput.value);
            maxLineLength = parseInt(maxInput.value);
            
            // Ensure min is not greater than max
            if (minLineLength > maxLineLength) {
                minLineLength = maxLineLength;
                minInput.value = minLineLength;
            }
            
            localStorage.setItem('minLineLength', minLineLength);
            localStorage.setItem('maxLineLength', maxLineLength);
        }
        
        function saveMode() {
            const select = document.getElementById('modeSelect');
            currentMode = select.value;
            localStorage.setItem('currentMode', currentMode);
            
            // Redraw canvas to apply new mode
            redrawCanvas();
        }
        
        function loadSettings() {
            const savedThreshold = localStorage.getItem('autoChangeThreshold');
            if (savedThreshold) {
                autoChangeThreshold = parseInt(savedThreshold);
                document.getElementById('thresholdInput').value = autoChangeThreshold;
            }
            
            const savedRadius = localStorage.getItem('indicatorRadius');
            if (savedRadius) {
                indicatorRadius = parseInt(savedRadius);
                document.getElementById('radiusInput').value = indicatorRadius;
            }
            
            const savedMinLength = localStorage.getItem('minLineLength');
            if (savedMinLength) {
                minLineLength = parseInt(savedMinLength);
                document.getElementById('minLengthInput').value = minLineLength;
            }
            
            const savedMaxLength = localStorage.getItem('maxLineLength');
            if (savedMaxLength) {
                maxLineLength = parseInt(savedMaxLength);
                document.getElementById('maxLengthInput').value = maxLineLength;
            }
            
            const savedMode = localStorage.getItem('currentMode');
            if (savedMode) {
                currentMode = savedMode;
                document.getElementById('modeSelect').value = currentMode;
            }
        }
        
        // Initialize
        loadSettings();
        initChart();
        generateNewLine();
    </script>
</body>
</html>