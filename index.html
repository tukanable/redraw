<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
            background: white;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 250px;
        }
        
        #accuracy {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        
        #attempts {
            font-size: 16px;
            color: #666;
            margin-bottom: 10px;
        }
        
        #lastResults {
            font-size: 14px;
            color: #555;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        #successRate {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        
        #settings {
            margin-bottom: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        
        #settings label {
            font-size: 12px;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }
        
        #thresholdInput, #radiusInput {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
            margin-right: 10px;
        }
        
        #graph {
            width: 200px;
            height: 100px;
            border: 1px solid #ddd;
            margin: 10px 0;
            background: white;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div id="accuracy">Точность: 0%</div>
        <div id="attempts">Попытка: 1</div>
        <div id="successRate">Успех за 10: 0%</div>
        <div id="lastResults">Последние 10: -</div>
        <div id="settings">
            <label for="thresholdInput">Авто-смена при %:</label>
            <input type="number" id="thresholdInput" min="50" max="99" value="98" onchange="saveThreshold()">
            <label for="radiusInput">Радиус индикатора:</label>
            <input type="number" id="radiusInput" min="50" max="200" value="100" onchange="saveRadius()">
        </div>
        <canvas id="graph"></canvas>
        <button onclick="generateNewLine()">Новая линия</button>
        <button onclick="clearAttempts()">Очистить попытки</button>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Line trainer system
        let targetLine = [];
        let userStrokes = []; // Array of strokes, each stroke is an array of points
        let currentStroke = [];
        let currentAccuracy = 0;
        let attemptHistory = [];
        let currentAttempt = 1;
        let autoChangeThreshold = 98;
        let currentMousePos = { x: 0, y: 0 };
        let indicatorRadius = 100;
        
        // Graph canvas
        const graphCanvas = document.getElementById('graph');
        const graphCtx = graphCanvas.getContext('2d');
        graphCanvas.width = 200;
        graphCanvas.height = 100;
        
        // Drawing settings
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        function startDrawing(e) {
            isDrawing = true;
            const [x, y] = getEventPos(e);
            [lastX, lastY] = [x, y];
            
            // Start new stroke
            currentStroke = [{ x, y }];
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const [currentX, currentY] = getEventPos(e);
            currentMousePos = { x: currentX, y: currentY };
            
            // Add point to current stroke
            currentStroke.push({ x: currentX, y: currentY });
            
            // Redraw everything
            redrawCanvas();
            
            // Calculate accuracy
            calculateAccuracy();
            
            [lastX, lastY] = [currentX, currentY];
        }
        
        function generateNewLine() {
            // Clear previous drawings
            userStrokes = [];
            currentStroke = [];
            targetLine = [];
            attemptHistory = [];
            currentAttempt = 1;
            
            // Generate random straight line
            const startX = Math.random() * canvas.width * 0.4 + canvas.width * 0.1;
            const startY = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;
            const endX = Math.random() * canvas.width * 0.4 + canvas.width * 0.5;
            const endY = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;
            
            // Generate points along the straight line
            const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const steps = Math.ceil(distance / 2); // Point every 2 pixels
            
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = startX + (endX - startX) * t;
                const y = startY + (endY - startY) * t;
                targetLine.push({ x, y });
            }
            
            currentAccuracy = 0;
            updateAccuracyDisplay();
            updateAttemptsDisplay();
            updateLastResultsDisplay();
            clearGraph();
            redrawCanvas();
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw target line (gray, dashed)
            if (targetLine.length > 1) {
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(targetLine[0].x, targetLine[0].y);
                for (let i = 1; i < targetLine.length; i++) {
                    ctx.lineTo(targetLine[i].x, targetLine[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw all user strokes
            ctx.lineWidth = 4;
            
            for (let stroke of userStrokes) {
                if (stroke.length > 1) {
                    drawColoredStroke(stroke);
                }
            }
            
            // Draw current stroke with color based on distance from target
            if (currentStroke.length > 1) {
                drawColoredStroke(currentStroke);
            }
            
            // Draw floating accuracy indicator near cursor
            if (isDrawing && currentMousePos.x > 0 && currentMousePos.y > 0) {
                drawFloatingAccuracy();
            }
        }
        
        function calculateAccuracy() {
            // Combine all user strokes and current stroke
            let allUserPoints = [];
            for (let stroke of userStrokes) {
                allUserPoints = allUserPoints.concat(stroke);
            }
            allUserPoints = allUserPoints.concat(currentStroke);
            
            if (allUserPoints.length === 0 || targetLine.length === 0) {
                currentAccuracy = 0;
                updateAccuracyDisplay();
                return;
            }
            
            // Calculate coverage - how much of the target line is covered
            let coveredTargetPoints = 0;
            const coverageThreshold = 15; // pixels
            
            for (let targetPoint of targetLine) {
                let isCovered = false;
                for (let userPoint of allUserPoints) {
                    const distance = Math.sqrt(
                        Math.pow(userPoint.x - targetPoint.x, 2) + 
                        Math.pow(userPoint.y - targetPoint.y, 2)
                    );
                    if (distance <= coverageThreshold) {
                        isCovered = true;
                        break;
                    }
                }
                if (isCovered) {
                    coveredTargetPoints++;
                }
            }
            
            const coverage = coveredTargetPoints / targetLine.length;
            
            // Calculate precision - how close user points are to target
            let totalDistance = 0;
            let validPoints = 0;
            
            for (let userPoint of allUserPoints) {
                let minDistance = Infinity;
                
                for (let targetPoint of targetLine) {
                    const distance = Math.sqrt(
                        Math.pow(userPoint.x - targetPoint.x, 2) + 
                        Math.pow(userPoint.y - targetPoint.y, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                }
                
                if (minDistance < 30) { // Only count points within 30px
                    totalDistance += minDistance;
                    validPoints++;
                }
            }
            
            let precision = 0;
            if (validPoints > 0) {
                const averageDistance = totalDistance / validPoints;
                precision = Math.max(0, Math.min(100, 100 - (averageDistance * 3)));
            }
            
            // Calculate overdrawn penalty
            const idealUserPoints = targetLine.length;
            const overdrawRatio = allUserPoints.length / idealUserPoints;
            let overdrawPenalty = 1;
            
            if (overdrawRatio > 1.2) {
                // Penalty for drawing too much
                overdrawPenalty = Math.max(0.5, 1 - (overdrawRatio - 1.2) * 0.5);
            }
            
            // Calculate overlap penalty (drawing multiple times over same area)
            let overlapPenalty = 1;
            let overlapCount = 0;
            
            for (let i = 0; i < allUserPoints.length; i++) {
                for (let j = i + 1; j < allUserPoints.length; j++) {
                    const distance = Math.sqrt(
                        Math.pow(allUserPoints[i].x - allUserPoints[j].x, 2) + 
                        Math.pow(allUserPoints[i].y - allUserPoints[j].y, 2)
                    );
                    if (distance < 5) { // Very close points indicate overlap
                        overlapCount++;
                    }
                }
            }
            
            if (overlapCount > allUserPoints.length * 0.1) {
                overlapPenalty = Math.max(0.7, 1 - (overlapCount / allUserPoints.length));
            }
            
            // Final accuracy combines coverage, precision, and penalties
            currentAccuracy = Math.max(0, Math.min(100, 
                coverage * precision * overdrawPenalty * overlapPenalty
            ));
            
            updateAccuracyDisplay();
        }
        
        function updateAccuracyDisplay() {
            document.getElementById('accuracy').textContent = `Точность: ${Math.round(currentAccuracy)}%`;
        }
        
        function stopDrawing() {
            if (isDrawing && currentStroke.length > 0) {
                // Calculate final accuracy for this attempt
                calculateAccuracy();
                
                // Record this attempt
                attemptHistory.push(currentAccuracy);
                currentAttempt++;
                updateAttemptsDisplay();
                updateLastResultsDisplay();
                updateGraph();
                
                // Check if average accuracy of last 10 attempts is above threshold
                if (attemptHistory.length >= 10) {
                    const last10 = attemptHistory.slice(-10);
                    const averageAccuracy = last10.reduce((sum, acc) => sum + acc, 0) / last10.length;
                    
                    if (averageAccuracy >= autoChangeThreshold) {
                        setTimeout(() => {
                            generateNewLine();
                        }, 1000); // Delay to show the result
                    }
                }
                
                // Clear all strokes after recording the result
                userStrokes = [];
                currentStroke = [];
                
                // Redraw canvas with only target line
                redrawCanvas();
            }
            isDrawing = false;
        }
        
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', (e) => {
            const [x, y] = getEventPos(e);
            currentMousePos = { x, y };
            draw(e);
        });
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events for tablet support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });
        
        // Prevent scrolling when touching the canvas
        document.body.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchend', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        function updateAttemptsDisplay() {
            document.getElementById('attempts').textContent = `Попытка: ${currentAttempt}`;
        }
        
        function updateLastResultsDisplay() {
            const last10 = attemptHistory.slice(-10);
            if (last10.length === 0) {
                document.getElementById('lastResults').textContent = 'Последние 10: -';
                document.getElementById('successRate').textContent = 'Успех за 10: 0%';
                return;
            }
            
            const resultsText = last10.map(acc => Math.round(acc) + '%').join(', ');
            document.getElementById('lastResults').textContent = `Последние ${last10.length}: ${resultsText}`;
            
            // Calculate average success rate
            const averageAccuracy = last10.reduce((sum, acc) => sum + acc, 0) / last10.length;
            const successRate = Math.round(averageAccuracy);
            document.getElementById('successRate').textContent = `Успех за 10: ${successRate}%`;
        }
        
        function getDistanceColor(distance) {
            // Color based on distance from target line
            // Green when close (0-5px), yellow (5-15px), red (15px+)
            if (distance < 5) {
                // Very close - bright green
                return 'rgb(0, 255, 0)';
            } else if (distance < 15) {
                // Medium distance - yellow to orange
                const progress = (distance - 5) / 10;
                const red = Math.round(255);
                const green = Math.round(255 * (1 - progress * 0.5));
                return `rgb(${red}, ${green}, 0)`;
            } else {
                // Far - red
                return 'rgb(255, 0, 0)';
            }
        }
        
        function drawColoredStroke(stroke) {
            if (stroke.length < 2) return;
            
            // Draw each segment with color based on distance to target
            for (let i = 1; i < stroke.length; i++) {
                const point = stroke[i];
                const prevPoint = stroke[i - 1];
                
                // Find minimum distance to target line for this point
                let minDistance = Infinity;
                for (let targetPoint of targetLine) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - targetPoint.x, 2) + 
                        Math.pow(point.y - targetPoint.y, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                }
                
                // Draw segment with appropriate color
                ctx.strokeStyle = getDistanceColor(minDistance);
                ctx.beginPath();
                ctx.moveTo(prevPoint.x, prevPoint.y);
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
        }
        
        function drawFloatingAccuracy() {
            const x = currentMousePos.x;
            const y = currentMousePos.y;
            
            // Find minimum distance to target line
            let minDistance = Infinity;
            for (let targetPoint of targetLine) {
                const distance = Math.sqrt(
                    Math.pow(x - targetPoint.x, 2) + 
                    Math.pow(y - targetPoint.y, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
            
            // Calculate radius based on distance
            // Close to line (0-5px) = small radius (10% of base)
            // Far from line (30px+) = full radius
            const maxDistance = 30;
            const normalizedDistance = Math.min(minDistance, maxDistance) / maxDistance;
            const minRadius = indicatorRadius * 0.1;
            const actualRadius = minRadius + (indicatorRadius - minRadius) * normalizedDistance;
            
            // Draw semi-transparent gray circle
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#888888';
            ctx.beginPath();
            ctx.arc(x, y, actualRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw border
            ctx.globalAlpha = 0.5;
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, actualRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function updateGraph() {
            if (attemptHistory.length === 0) return;
            
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            
            // Draw grid
            graphCtx.strokeStyle = '#e0e0e0';
            graphCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (i / 5) * graphCanvas.height;
                graphCtx.beginPath();
                graphCtx.moveTo(0, y);
                graphCtx.lineTo(graphCanvas.width, y);
                graphCtx.stroke();
            }
            
            // Draw accuracy line
            if (attemptHistory.length > 1) {
                graphCtx.strokeStyle = '#007bff';
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();
                
                for (let i = 0; i < attemptHistory.length; i++) {
                    const x = (i / (attemptHistory.length - 1)) * graphCanvas.width;
                    const y = graphCanvas.height - (attemptHistory[i] / 100) * graphCanvas.height;
                    
                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                }
                graphCtx.stroke();
                
                // Draw points
                graphCtx.fillStyle = '#007bff';
                for (let i = 0; i < attemptHistory.length; i++) {
                    const x = (i / (attemptHistory.length - 1)) * graphCanvas.width;
                    const y = graphCanvas.height - (attemptHistory[i] / 100) * graphCanvas.height;
                    graphCtx.beginPath();
                    graphCtx.arc(x, y, 3, 0, Math.PI * 2);
                    graphCtx.fill();
                }
            }
        }
        
        function clearGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
        }
        
        function clearAttempts() {
            userStrokes = [];
            currentStroke = [];
            attemptHistory = [];
            currentAttempt = 1;
            currentAccuracy = 0;
            updateAccuracyDisplay();
            updateAttemptsDisplay();
            updateLastResultsDisplay();
            clearGraph();
            redrawCanvas();
        }
        
        function saveThreshold() {
            const input = document.getElementById('thresholdInput');
            autoChangeThreshold = parseInt(input.value);
            localStorage.setItem('autoChangeThreshold', autoChangeThreshold);
        }
        
        function saveRadius() {
            const input = document.getElementById('radiusInput');
            indicatorRadius = parseInt(input.value);
            localStorage.setItem('indicatorRadius', indicatorRadius);
        }
        
        function loadSettings() {
            const savedThreshold = localStorage.getItem('autoChangeThreshold');
            if (savedThreshold) {
                autoChangeThreshold = parseInt(savedThreshold);
                document.getElementById('thresholdInput').value = autoChangeThreshold;
            }
            
            const savedRadius = localStorage.getItem('indicatorRadius');
            if (savedRadius) {
                indicatorRadius = parseInt(savedRadius);
                document.getElementById('radiusInput').value = indicatorRadius;
            }
        }
        
        // Initialize
        loadSettings();
        generateNewLine();
    </script>
</body>
</html>